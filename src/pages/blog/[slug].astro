---
import Layout from '../../layouts/Layout.astro';
import BlogPostHeader from '../../components/sections/blogPost/BlogPostHeader.astro';
import BlogPostHero from '../../components/sections/blogPost/BlogPostHero.astro';
import ContentRenderer from '../../components/content/ContentRenderer.astro';
import BlogPostAuthor from '../../components/sections/blogPost/BlogPostAuthor.astro';
import BlogPostEngagement from '../../components/sections/blogPost/BlogPostEngagement.astro';
import BlogPostRelated from '../../components/sections/blogPost/BlogPostRelated.astro';
import { portfolioAPI } from '../../lib/api';

export async function getStaticPaths() {
  console.log('ðŸ” Blog getStaticPaths ejecutÃ¡ndose...');
  
  try {
    const blogPostsResponse = await portfolioAPI.getBlogPosts();
    const blogPosts = blogPostsResponse.success ? blogPostsResponse.data : [];
    const paths = blogPosts.map((blogPostData) => ({
      params: { slug: blogPostData.slug },
      props: { blogPostData }  
    }));
    
    console.log(`ðŸ“ Generated paths for ${paths.length} blog posts`);
    return paths;
  } catch (error) {
    console.error('âŒ Error generating blog paths:', error);
    return [];
  }
}

const { blogPostData } = Astro.props;

if (!blogPostData) {
  return Astro.redirect('/404');
}

console.log('âœ… Blog post cargado:', blogPostData.title);

// Transform API data to match component expectations
const transformedPost = {
  // Core content
  id: blogPostData.id.toString(),
  slug: blogPostData.slug,
  title: blogPostData.title,
  subtitle: blogPostData.subtitle || '',
  excerpt: blogPostData.excerpt,
  
  // Metadata
  publishedAt: blogPostData.publishedAt || blogPostData.createdAt,
  updatedAt: blogPostData.updatedAt,
  readTime: blogPostData.readTime || 5,
  wordCount: blogPostData.wordCount || 0,
  views: blogPostData.views || 0,
  
  // Organization
  category: blogPostData.category?.name || 'Uncategorized',
  tags: blogPostData.blogPostTags?.map(tag => tag.blogTag.name) || [],
  series: blogPostData.series ? {
    name: blogPostData.series.name,
    part: blogPostData.seriesPart || 1,
    total: blogPostData.series.totalParts || 1,
    nextPost: null
  } : null,
  
  // Media - exact format expected by BlogPostHero
  heroImage: blogPostData.heroImage ? {
    url: blogPostData.heroImage,
    alt: blogPostData.heroImageAlt || blogPostData.title,
    caption: blogPostData.heroImageCaption || ''
  } : null,
  
  // Content blocks - pass directly to ContentRenderer
  contentBlocks: blogPostData.contentBlocks || [],
  
  // Author - from JSON field
  author: blogPostData.author || {
    name: "David Rodriguez",
    bio: "Full-stack developer passionate about cloud infrastructure and developer experience.",
    avatar: "/author-avatar.jpg",
    social: {
      twitter: "#",
      github: "#",
      linkedin: "#"
    }
  },
  
  // Reactions for engagement
  reactions: {
    likes: 0,
    loves: 0,
    bookmarks: 0
  },
  
  // SEO
  metaDescription: blogPostData.metaDescription || blogPostData.excerpt,
  socialImage: blogPostData.socialImage || blogPostData.heroImage || ''
};

// Fetch related posts (same category, excluding current post)
const relatedResponse = await portfolioAPI.getBlogPosts();
const relatedPosts = relatedResponse.success && Array.isArray(relatedResponse.data) ? 
  relatedResponse.data
    .filter(post => post.id !== blogPostData.id && post.category?.name === blogPostData.category?.name)
    .slice(0, 3)
    .map(post => ({
      slug: post.slug,
      title: post.title,
      excerpt: post.excerpt,
      image: post.heroImage,
      readTime: post.readTime || 5,
      category: post.category?.name || 'uncategorized',
      publishedAt: post.publishedAt || post.createdAt
    })) : [];
---

<Layout>
  <!-- Reading Progress Bar -->
  <div id="reading-progress" class="fixed top-0 left-0 w-full h-1 bg-gray-200 z-50">
    <div id="progress-bar" class="h-full bg-yellow-400 transition-all duration-300" style="width: 0%"></div>
  </div>

  <!-- Navigation -->
  <nav class="fixed top-0 left-0 right-0 z-40 bg-white/80 backdrop-blur-sm border-b border-gray-200 mt-1">
    <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex items-center justify-between h-16">
        <a 
          href="/blog" 
          class="inline-flex items-center text-sm font-medium text-gray-600 hover:text-black transition-colors duration-300"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2">
            <path d="M19 12H5"/>
            <path d="m12 19-7-7 7-7"/>
          </svg>
          Back to Blog
        </a>

        <div class="hidden sm:flex items-center space-x-4 text-xs text-gray-500">
          <span>{transformedPost.readTime} min read</span>
          <span>â€¢</span>
          <span>{transformedPost.views.toLocaleString()} views</span>
        </div>
      </div>
    </div>
  </nav>

  <!-- Main Content -->
  <main class="pt-16">
    <BlogPostHeader post={transformedPost} />
    <BlogPostHero post={transformedPost} />
    
    <section class="px-4 sm:px-6 lg:px-8 mb-16">
      <div class="max-w-4xl mx-auto">
        <ContentRenderer blocks={transformedPost.contentBlocks} />
      </div>
    </section>
    
    <BlogPostAuthor author={transformedPost.author} />
    <BlogPostEngagement post={transformedPost} />
    <BlogPostRelated posts={relatedPosts} series={transformedPost.series} />
  </main>
</Layout>

<script>
  function updateReadingProgress() {
    const article = document.querySelector('main');
    const progressBar = document.getElementById('progress-bar');
    
    if (!article || !progressBar) return;
    
    const scrollTop = window.pageYOffset;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const scrollPercent = (scrollTop / docHeight) * 100;
    
    progressBar.style.width = Math.min(100, Math.max(0, scrollPercent)) + '%';
  }
  
  window.addEventListener('scroll', updateReadingProgress);
  window.addEventListener('resize', updateReadingProgress);
</script>